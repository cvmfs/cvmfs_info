#!/usr/bin/perl
# This file is part of the CernVM File System.
# Copyright CERN, BSD licensed.
# Contact: jblomer@cern.ch

use strict;
use warnings;

use Compress::Zlib;
use Data::Dumper;
use File::Fetch;
use Getopt::Std;
use JSON;
use Time::Local;


# Usage and version information
# ------------------------------------------------------------------------------

my $VERSION = 0.1;
my $CONTACT = "jblomer\@cern.ch";

sub main::HELP_MESSAGE {
  print "Queries the replication status of CernVM-FS repositories.\n";
  print "Usage:\n  $0 [options]\n";
  print "Options: \n";
  print "  -d  Repsitory data file\n";
  print "  -r  Repository, either by url or by name\n";
  print "  -y  to be defined\n";
}

sub main::VERSION_MESSAGE {
  print "$0 version $VERSION (contact: $CONTACT)\n";
}


# Constants and sub routines
# ------------------------------------------------------------------------------

my $SUCCESS = "ok";
$File::Fetch::WARN = 0;  # we check manually for errors

my %host_db;

sub main::findHost {
  my ($repo_name) = (shift);

}

sub main::convertWhitelistDate {
  my ($timestamp) = (shift);

  my $year = substr($timestamp, 0, 4);
  my $month = substr($timestamp, 4, 2) - 1;
  my $day = substr($timestamp, 6, 2);
  my $hour = substr($timestamp, 8, 2);
  my $minute = substr($timestamp, 10, 2);
  my $second = substr($timestamp, 12, 2);
  my $time_gmt = timegm($second, $minute, $hour, $day, $month, $year);
  my $time_diff = ($time_gmt - time()) / 84600;
  return int($time_diff) . 'd';
}

sub main::shortTime {
  my ($timestamp) = (shift);
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
    localtime($timestamp);
  return sprintf("%04d-%02d-%02d %02d:%02d",
                 $year + 1900, $mon + 1, $mday, $hour, $min);
}

sub extractHost {
  my ($url) = (shift);
  $url =~ m,^(http://)?([^:/]+).*,;
  my $host = $2;
  if (exists($host_db{'hosts'}) && exists($host_db{'hosts'}{$host})) {
    return $host_db{'hosts'}{$host}{'name'};
  }
  return $host;
}

sub extractName {
  my ($url) = (shift);
  $url =~ m,(^.*/cvmfs)/([^/]+)$,;
  return $2;
}

# From manifest, whitelist, meta info, server info, and repository list on
# the host, construct all relevant data bits.
sub main::expandInfo {
  my ($info, $url) = (shift, shift);

  $info->{'host'} = extractHost($url);
  $info->{'whitelist_expires'}
    = convertWhitelistDate($info->{'whitelist_expires'});
  $info->{'gc'} = 'no' if (!defined($info->{'gc'}));
  $info->{'gc'} = '-' if ($info->{'gc'} eq 'no');
  $info->{'ttl'} = ($info->{'ttl'} / 60) . 'mn';
  $info->{'last_update'} = shortTime($info->{'last_update'});
  $info->{'type'} = '?';
  $info->{'status'} = 'online';
  $info->{'server_info'} = decode_json($info->{'server_info'});
  if (!defined($info->{'server_info'}->{'email'})) {
    $info->{'host_contact'} = '-';
  } else {
    $info->{'host_contact'} = $info->{'server_info'}->{'email'};
  }
  $info->{'stratum0'} =
    decode_json($info->{'metainfo'})->{'recommended-stratum0'};
  $info->{'stratum1s'} =
    decode_json($info->{'metainfo'})->{'recommended-stratum1s'};
}

# Gathers information about a particular repository on a particular host
sub main::collectInfo {
  my ($url) = (shift);
  $url =~ s,(.*)/(\.cvmfspublished)?$,$1,;  # get repo base url
  my %info;

  print STDERR "--> querying $url\n";

  my $raw_manifest;
  my $ff = File::Fetch->new(uri => $url . '/.cvmfspublished');
  $ff->fetch(to => \$raw_manifest) || return ($ff->error("verbose"), ());
  my @manifest_lines = split /\n/, $raw_manifest;

  my $raw_whitelist;
  $ff = File::Fetch->new(uri => $url . '/.cvmfswhitelist');
  $ff->fetch(to => \$raw_whitelist) || return ($ff->error("verbose"), ());
  my @whitelist_lines = split /\n/, $raw_whitelist;

  my $server_info;
  my $server_repos;
  $url =~ m,(^.*/cvmfs)/[^/]+$,;
  my $base_url = $1;
  $ff = File::Fetch->new(uri => $base_url . '/info/v1/meta.json');
  if ($ff->fetch(to => \$server_info)) {
    $info{'server_info'} = $server_info;
  } else {
    $info{'server_info'} = '{}';
  }
  $ff = File::Fetch->new(uri => $base_url . '/info/v1/repositories.json');
  if ($ff->fetch(to => \$server_repos)) {
    $info{'server_repos'} = $server_repos;
  } else {
    $info{'server_repos'} = '{}';
  }

  foreach my $line (@manifest_lines) {
    last if ($line eq "--");
    my $key = substr($line, 0, 1);
    my $value = substr($line, 1);
    $info{'catalog'}     = $value if ($key eq 'C');
    $info{'gc'}          = $value if ($key eq 'G');
    $info{'last_update'} = $value if ($key eq 'T');
    $info{'metainfo'}    = $value if ($key eq 'M');
    $info{'name'}        = $value if ($key eq 'N');
    $info{'revision'}    = $value if ($key eq 'S');
    $info{'ttl'}         = $value if ($key eq 'D');
  }
  my $whitelist;
  foreach my $line (@whitelist_lines) {
    my $key = substr($line, 0, 1);
    my $value = substr($line, 1);
    if ($key eq 'E') {
      $info{'whitelist_expires'} = $value;
      last;
    }
  }
  if (defined($info{'metainfo'})) {
    my ($error, $json) = fetchMetainfo($url, $info{'metainfo'});
    return ($error, ()) if ($error ne $SUCCESS);
    $info{'metainfo'} = $json;
  } else {
    $info{'metainfo'} = '{}';
  }

  expandInfo(\%info, $url);
  return ($SUCCESS, %info);
}

sub main::fetchMetainfo {
  my ($url, $hash) = (shift, shift);
  my $uri =
    $url . '/data/' . substr($hash, 0, 2) . '/' . substr($hash, 2) . 'M';

  my $metainfo_compressed;
  my $ff = File::Fetch->new(uri => $uri);
  $ff->fetch(to => \$metainfo_compressed) || return ($ff->error("verbose"), ());
  my $metainfo = uncompress($metainfo_compressed) ||
    return ("fail to uncompress metainfo at $uri", ());
  return ($SUCCESS, $metainfo);
}

sub main::printRepoInfo {
  my ($manifest_ref) = (shift);

format STDOUT_TOP =
HOST                  TYPE    STATUS    REVISION    LAST UPDATED        LAST GC     TTL      RESIGN IN    HOST CONTACT
----------------------------------------------------------------------------------------------------------------------
.
  format STDOUT =
@<<<<<<<<<<<<<<...    @<<<<   @<<<<<   @########    @<<<<<<<<<<<<<<<    @>>>>>>     @<<<<<   @>>>>>>>>    @<<<<<<<<<<<<<<<<<<<...
$manifest_ref->{'host'}, $manifest_ref->{'type'}, $manifest_ref->{'status'}, $manifest_ref->{'revision'}, $manifest_ref->{'last_update'}, $manifest_ref->{'gc'}, $manifest_ref->{'ttl'}, $manifest_ref->{'whitelist_expires'}, $manifest_ref->{'host_contact'}
.
  write;
}


# Main routine
# ------------------------------------------------------------------------------

# Option parsing
$Getopt::Std::STANDARD_HELP_VERSION = 1;
our($opt_d, $opt_r, $opt_y, $opt_h, $opt_v);
getopts('d:r:y:hv');
if ($opt_v) {
  VERSION_MESSAGE();
  exit 0;
}
if ($opt_h) {
  VERSION_MESSAGE();
  HELP_MESSAGE();
  exit 0;
}
if ($opt_d) {
  %host_db = $opt_d;
} else {
  %host_db = do "$0.data" if (-e "$0.data");
}
my $repository = $opt_r;

my ($error, %manifest) = collectInfo($repository);
die "FATAL: $error" if ($error ne $SUCCESS);
my @infos = [\%manifest];
foreach my $stratum1 (@{$manifest{'stratum1s'}}) {
  my ($error, %info) = collectInfo($stratum1) || print "ERROR $error\n";
}
printRepoInfo(\%manifest);
